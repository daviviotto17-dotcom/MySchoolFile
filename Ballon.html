<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo de Balão de ar quente</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            color: white;
            flex-direction: column;
            text-align: center;
        }
        canvas {
            display: block;
        }
        .menu-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            flex-direction: column;
            gap: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 40px;
            border-radius: 10px;
            z-index: 100;
        }
        .menu-screen button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
        #initial-menu {
            display: flex;
        }
        #pause-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px;
            font-size: 18px;
            cursor: pointer;
            z-index: 50;
            line-height: 1;
        }
        .powerup-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
            flex-shrink: 0;
        }
        .instructions-item {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        /* Animação para a bolinha de vida extra nas instruções */
        .extra-life-icon-animated {
            animation: color-change 1s infinite;
        }
        @keyframes color-change {
            0% { background-color: #FF0000; }
            14% { background-color: #FFA500; }
            28% { background-color: #FFFF00; }
            42% { background-color: #008000; }
            57% { background-color: #0000FF; }
            71% { background-color: #4B0082; }
            85% { background-color: #EE82EE; }
            100% { background-color: #FF0000; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="initial-menu" class="menu-screen">
        <h1>Jogo do Balão de ar quente</h1>
        <button id="showInstructionsButton">Jogar</button>
    </div>

    <div id="instructions-menu" class="menu-screen" style="display:none;">
        <h1>Instruções</h1>
        <p style="font-size: 14px;">Para jogar você deve desviar de quadrados vermelhos e pegar os bônus para te ajudar.</p>
        <span><strong>Bônus:</strong></span>
        <div class="instructions-item">
            <div class="powerup-icon" style="background-color: blue;"></div>
            <span>Invencibilidade: te dá 5 segundos de invencibilidade e velocidade.</span>
        </div>
        <div class="instructions-item">
            <div class="powerup-icon" style="background-color: green;"></div>
            <span>Escudo: te protege de um único impacto e te dá 2 segundos de invencibilidade.</span>
        </div>
        <div class="instructions-item">
            <div class="powerup-icon" style="background-color: purple;"></div>
            <span>Ímã: puxa os bônus para você.</span>
        </div>
        <div class="instructions-item">
            <div class="powerup-icon extra-life-icon-animated"></div>
            <span>Vida Extra: te dá uma vida a mais. É um bônus muito raro.</span>
        </div>
        <button id="startGameButton">Iniciar Jogo</button>
    </div>

    <div id="pause-menu" class="menu-screen" style="display:none;">
        <h1>Jogo Pausado</h1>
        <button id="resumeGameButton">Continuar</button>
    </div>

    <div id="game-over-screen" class="menu-screen">
        <h1>Game Over!</h1>
        <p>Sua pontuação final é: <span id="finalScore">0</span></p>
        <button id="playAgainButton">Jogar Novamente</button>
    </div>

    <button id="pause-button" style="display: none;">⏸</button>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const initialMenu = document.getElementById('initial-menu');
        const instructionsMenu = document.getElementById('instructions-menu');
        const pauseMenu = document.getElementById('pause-menu');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const showInstructionsButton = document.getElementById('showInstructionsButton');
        const startGameButton = document.getElementById('startGameButton');
        const resumeGameButton = document.getElementById('resumeGameButton');
        const pauseButton = document.getElementById('pause-button');
        const playAgainButton = document.getElementById('playAgainButton');

        let screenWidth = window.innerWidth;
        let screenHeight = window.innerHeight;
        canvas.width = screenWidth;
        canvas.height = screenHeight;

        const playerWidth = 80;
        const playerHeight = 110;
        let playerX = screenWidth / 2 - playerWidth / 2;
        let playerY = screenHeight - playerHeight - 20;
        let playerSpeed = 8;
        
        let obstacles = [];
        let powerups = [];
        let clouds = [];
        let breakingAnimations = [];
        let score = 0;
        let lives = 3;
        let gameOver = false;
        let isPaused = false;
        let lastMouseX = null;
        let lastTime = 0;
        let animationFrameId = null;

        let isInvincible = false;
        let isShielded = false;
        let isMagnetic = false;
        let invincibilityTimer = 0;
        let shieldTimer = 0;
        let magneticTimer = 0;
        let magneticSpawnCount = 0;

        const invincibilityDuration = 5000;
        const shieldDuration = 5000;
        const magneticDuration = 5000;
        const initialInvincibilityDuration = 3000;
        const flashingStart = 3000;
        const invincibilityAfterShieldDuration = 2000;
        let isFlashing = false;
        
        const extraLifeColors = ['#FF0000', '#FFA500', '#FFFF00', '#008000', '#0000FF', '#4B0082', '#EE82EE'];
        const extraLifeColorChangeInterval = 100;
        let lastColorChange = 0;
        let extraLifeColorIndex = 0;

        // Variáveis para a contagem regressiva e velocidade
        let isCountingDown = false;
        const COUNTDOWN_DURATION = 3000; // 3 segundos
        let countdownStartTime;

        const playerImage = new Image();
        playerImage.src = 'https://i.postimg.cc/4KF7RwqW/1000042151-removebg-preview.png';

        const cloudImageSources = [
            'https://i.ibb.co/N2fG6Hyc/1000042129-removebg-preview-1.png',
            'https://i.ibb.co/20RwG992/1000042129-removebg-preview-2.png',
            'https://i.ibb.co/JjgSZN8r/1000042129-removebg-preview-3.png',
            'https://i.ibb.co/PzfbrNtL/1000042129-removebg-preview-4.png',
            'https://i.ibb.co/4n2mJB3g/1000042129-removebg-preview.png'
        ];
        const cloudImages = cloudImageSources.map(src => {
            const img = new Image();
            img.src = src;
            return img;
        });

        const gradientColors = [
            { score: 0, color: '#68A9FF' },
            { score: 2000, color: '#6C25A0' },
            { score: 6000, color: '#000033' }
        ];
        
        // Variáveis para a transição de velocidade
        let currentObstacleSpeed = 0;
        let targetObstacleSpeed = 0;
        const SPEED_TRANSITION_DURATION = 3000; // 3 segundos
        let speedTransitionStartTime;

        function handleResize() {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            canvas.width = screenWidth;
            canvas.height = screenHeight;
            playerX = screenWidth / 2 - playerWidth / 2;
            playerY = screenHeight - playerHeight - 20;
        }

        function hexToRgb(hex) {
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            return [r, g, b];
        }

        function interpolateColor(color1, color2, factor) {
            const c1 = hexToRgb(color1);
            const c2 = hexToRgb(color2);
            const r = Math.round(c1[0] + factor * (c2[0] - c1[0]));
            const g = Math.round(c1[1] + factor * (c2[1] - c1[1]));
            const b = Math.round(c1[2] + factor * (c2[2] - c1[2]));
            return `rgb(${r}, ${g}, ${b})`;
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, screenHeight, 0, 0);

            let topColor = gradientColors[0].color;
            let bottomColor = gradientColors[0].color;
            
            for (let i = 0; i < gradientColors.length - 1; i++) {
                if (score >= gradientColors[i].score && score < gradientColors[i + 1].score) {
                    const startScore = gradientColors[i].score;
                    const endScore = gradientColors[i + 1].score;
                    const factor = (score - startScore) / (endScore - startScore);
                    
                    bottomColor = interpolateColor(gradientColors[i].color, gradientColors[i + 1].color, factor);
                    topColor = interpolateColor(gradientColors[i+1].color, gradientColors[Math.min(i + 2, gradientColors.length - 1)].color, factor);
                    
                    break;
                }
            }

            if (score >= gradientColors[gradientColors.length - 1].score) {
                bottomColor = gradientColors[gradientColors.length - 1].color;
                topColor = gradientColors[gradientColors.length - 1].color;
            }

            gradient.addColorStop(0, bottomColor);
            gradient.addColorStop(1, topColor);

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, screenWidth, screenHeight);
        }
        
        function drawClouds() {
            for (let i = 0; i < clouds.length; i++) {
                ctx.globalAlpha = clouds[i].opacity;
                ctx.drawImage(clouds[i].image, clouds[i].x, clouds[i].y, clouds[i].size, clouds[i].size);
            }
            ctx.globalAlpha = 1;
        }

        function drawPlayer() {
            ctx.save();
            const playerCenterX = playerX + playerWidth / 2;
            const playerCenterY = playerY + playerHeight / 2;

            if (isInvincible) {
                const pulse = Math.abs(Math.sin(Date.now() / 300));
                ctx.beginPath();
                ctx.arc(playerCenterX, playerCenterY, playerWidth * (0.6 + pulse * 0.1), 0, Math.PI * 2);
                ctx.fillStyle = `rgba(0, 191, 255, ${pulse * 0.5 + 0.2})`;
                ctx.fill();
            }

            if (isFlashing) {
                const alpha = (Math.floor(Date.now() / 150) % 2) === 0 ? 1 : 0.1;
                ctx.globalAlpha = alpha;
            }
            
            ctx.drawImage(playerImage, playerX, playerY, playerWidth, playerHeight);

            ctx.restore();

            if (isShielded) {
                ctx.beginPath();
                ctx.arc(playerCenterX, playerCenterY, playerWidth * 0.7, 0, Math.PI * 2);
                ctx.strokeStyle = 'cyan';
                ctx.lineWidth = 3;
                ctx.stroke();
            }
        }

        function drawPlayerFallback() {
            ctx.fillStyle = 'yellow';
            ctx.fillRect(playerX, playerY, playerWidth, playerHeight);
        }

        function drawObstacles() {
            ctx.fillStyle = 'red';
            for (let i = 0; i < obstacles.length; i++) {
                ctx.fillRect(obstacles[i].x, obstacles[i].y, obstacles[i].size, obstacles[i].size);
            }
        }

        function drawPowerups() {
            for (let i = 0; i < powerups.length; i++) {
                const pu = powerups[i];
                if (pu.type === 'invincibility') {
                    ctx.fillStyle = 'blue';
                } else if (pu.type === 'shield') {
                    ctx.fillStyle = 'green';
                } else if (pu.type === 'magnetic') {
                    ctx.fillStyle = 'purple';
                } else if (pu.type === 'extraLife') {
                    ctx.fillStyle = extraLifeColors[extraLifeColorIndex];
                }
                
                const pulseRadius = pu.size / 2 + Math.sin(Date.now() / 150) * 5;
                ctx.beginPath();
                ctx.arc(pu.x + pu.size / 2, pu.y + pu.size / 2, pulseRadius, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function drawBreakingAnimations() {
            for (let i = 0; i < breakingAnimations.length; i++) {
                const anim = breakingAnimations[i];
                const opacity = anim.lifetime / 500;
                ctx.fillStyle = anim.color;
                ctx.globalAlpha = opacity;
                
                for (let p = 0; p < anim.particles.length; p++) {
                    const particle = anim.particles[p];
                    ctx.fillRect(particle.x, particle.y, particle.size, particle.size);
                }
            }
            ctx.globalAlpha = 1;
        }

        function drawBonusTimer() {
            if (isInvincible) {
                const timeLeft = Math.max(0, Math.ceil(invincibilityTimer / 1000));
                ctx.fillStyle = 'blue';
                ctx.beginPath();
                ctx.arc(40, 130, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText(timeLeft, 30, 137);
            }
            if (isShielded) {
                const timeLeft = Math.max(0, Math.ceil(shieldTimer / 1000));
                ctx.fillStyle = 'green';
                ctx.beginPath();
                ctx.arc(100, 130, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText(timeLeft, 90, 137);
            }
            if (isMagnetic) {
                const timeLeft = Math.max(0, Math.ceil(magneticTimer / 1000));
                ctx.fillStyle = 'purple';
                ctx.beginPath();
                ctx.arc(160, 130, 20, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = '20px Arial';
                ctx.fillText(timeLeft, 150, 137);
            }
        }
        
        function drawLives() {
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.fillText('Vidas: ' + lives, 10, 60);
        }
        
        function getPlayerHitboxPath(x, y, width, height) {
            const topY = y + height * 0.1;
            const bottomY = y + height * 0.9;
            const leftX = x + width * 0.1;
            const rightX = x + width * 0.9;
            const centerX = x + width / 2;
            const bottomTipY = y + height;

            const path = new Path2D();
            path.moveTo(centerX, topY);
            path.bezierCurveTo(rightX, y, x + width, y + height * 0.2, x + width, bottomY);
            path.lineTo(x + width * 0.6, bottomTipY);
            path.lineTo(x + width * 0.4, bottomTipY);
            path.bezierCurveTo(x, y + height * 0.2, leftX, y, centerX, topY);
            path.closePath();
            return path;
        }

        function isColliding(obstacle) {
            const playerPath = getPlayerHitboxPath(playerX, playerY, playerWidth, playerHeight);
            
            return (
                ctx.isPointInPath(playerPath, obstacle.x, obstacle.y) ||
                ctx.isPointInPath(playerPath, obstacle.x + obstacle.size, obstacle.y) ||
                ctx.isPointInPath(playerPath, obstacle.x, obstacle.y + obstacle.size) ||
                ctx.isPointInPath(playerPath, obstacle.x + obstacle.size, obstacle.y + obstacle.size)
            );
        }

        function update(deltaTime) {
            if (gameOver || isPaused || isCountingDown) return;

            let obstacleSpeed = 2 + score / 750;
            
            // Lógica de transição de velocidade após a contagem
            if (speedTransitionStartTime) {
                const elapsed = performance.now() - speedTransitionStartTime;
                const progress = Math.min(elapsed / SPEED_TRANSITION_DURATION, 1);
                obstacleSpeed = 2 + (targetObstacleSpeed - 2) * progress;

                if (progress >= 1) {
                    speedTransitionStartTime = null; // Fim da transição
                    obstacleSpeed = targetObstacleSpeed;
                }
            } else {
                obstacleSpeed = 2 + score / 750;
            }

            // Aplica a velocidade atualizada a todos os obstáculos
            for(let i = 0; i < obstacles.length; i++){
                obstacles[i].speed = obstacleSpeed + (isInvincible ? 1.5 : 0);
            }
            for(let i = 0; i < powerups.length; i++){
                powerups[i].speed = obstacleSpeed;
            }
            for(let i = 0; i < clouds.length; i++){
                clouds[i].speed = 0.5 + Math.random() * 0.5; // Nuvens não dependem da pontuação
            }


            if (isInvincible) {
                invincibilityTimer -= deltaTime;
                if (invincibilityTimer <= flashingStart && !isFlashing) {
                    isFlashing = true;
                }
                if (invincibilityTimer <= 0) {
                    isInvincible = false;
                    isFlashing = false;
                    playerSpeed = 8;
                }
            }
            
            if (isShielded && !isInvincible) {
                shieldTimer -= deltaTime;
                if (shieldTimer <= 0) {
                    isShielded = false;
                }
            }

            if (isMagnetic) {
                magneticTimer -= deltaTime;
                if (magneticTimer <= 0) {
                    isMagnetic = false;
                    magneticSpawnCount = 0;
                }
            }
            
            if (performance.now() - lastColorChange > extraLifeColorChangeInterval) {
                extraLifeColorIndex = (extraLifeColorIndex + 1) % extraLifeColors.length;
                lastColorChange = performance.now();
            }
            
            for (let i = breakingAnimations.length - 1; i >= 0; i--) {
                const anim = breakingAnimations[i];
                anim.lifetime -= deltaTime;
                
                for (let p = 0; p < anim.particles.length; p++) {
                    const particle = anim.particles[p];
                    particle.x += particle.dx * (deltaTime / 16);
                    particle.y += particle.dy * (deltaTime / 16);
                    particle.size -= 0.1;
                }

                if (anim.lifetime <= 0) {
                    breakingAnimations.splice(i, 1);
                }
            }

            const speedMultiplier = deltaTime / (1000 / 60);
            for (let i = 0; i < obstacles.length; i++) {
                obstacles[i].y += obstacles[i].speed * speedMultiplier;
            }

            for (let i = 0; i < powerups.length; i++) {
                powerups[i].y += powerups[i].speed * speedMultiplier;
            }

            for (let i = 0; i < clouds.length; i++) {
                clouds[i].y += clouds[i].speed * speedMultiplier;
            }
            
            if (Math.random() < 0.002) {
                const size = 60 + Math.random() * 40;
                const opacity = 0.5 + Math.random() * 0.5;
                const speed = 0.5 + Math.random() * 0.5;
                const randomCloudImage = cloudImages[Math.floor(Math.random() * cloudImages.length)];
                clouds.push({
                    x: Math.random() * (screenWidth - size),
                    y: -size,
                    size: size,
                    opacity: opacity,
                    speed: speed,
                    image: randomCloudImage
                });
            }

            clouds = clouds.filter(item => item.y < screenHeight);

            if (isMagnetic) {
                const magneticStrength = 0.05;
                for (let i = powerups.length - 1; i >= 0; i--) {
                    const item = powerups[i];
                    if (item.y > screenHeight) {
                        item.y = -item.size;
                    }

                    const dx = playerX - item.x;
                    const dy = playerY - item.y;
                    item.x += dx * magneticStrength;
                    item.y += dy * magneticStrength;
                }
            } else {
                powerups = powerups.filter(item => item.y < screenHeight);
            }
            
            obstacles = obstacles.filter(item => item.y < screenHeight);

            if (isMagnetic) {
                if (powerups.length === 0 && magneticSpawnCount > 0) {
                    const size = 30;
                    const speed = currentObstacleSpeed;
                    const powerupTypes = ['invincibility', 'shield']; 
                    const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                    powerups.push({
                        x: Math.random() * (screenWidth - size),
                        y: -size,
                        size: size,
                        speed: speed,
                        type: randomType,
                        generatedByMagnet: true
                    });
                    magneticSpawnCount--;
                }
            }

            const obstacleSpawnRate = score < 100 ? 0.005 : 0.015;
            if (Math.random() < obstacleSpawnRate) {
                const size = 30 + Math.random() * 40;
                const speed = currentObstacleSpeed + (isInvincible ? 1.5 : 0);
                obstacles.push({
                    x: Math.random() * (screenWidth - size),
                    y: -size,
                    size: size,
                    speed: speed
                });
            }

            // Aumenta a chance da vida extra quando o jogador tem 1 vida
            const extraLifeSpawnRate = (lives === 1) ? 0.0005 : 0.0001; 
            
            if (Math.random() < extraLifeSpawnRate && powerups.length < 2) {
                const size = 25;
                const speed = currentObstacleSpeed;
                powerups.push({
                    x: Math.random() * (screenWidth - size),
                    y: -size,
                    size: size,
                    speed: speed,
                    type: 'extraLife',
                    generatedByMagnet: false
                });
            } else if (Math.random() < 0.001 && powerups.length < 2) {
                const powerupTypes = ['invincibility', 'shield', 'magnetic'];
                const randomType = powerupTypes[Math.floor(Math.random() * powerupTypes.length)];
                
                const size = 30;
                const speed = currentObstacleSpeed;
                powerups.push({
                    x: Math.random() * (screenWidth - size),
                    y: -size,
                    size: size,
                    speed: speed,
                    type: randomType,
                    generatedByMagnet: false
                });
            }

            score++;

            for (let i = powerups.length - 1; i >= 0; i--) {
                const pu = powerups[i];
                if (
                    playerX < pu.x + pu.size &&
                    playerX + playerWidth > pu.x &&
                    playerY < pu.y + pu.size &&
                    playerY + playerHeight > pu.y
                ) {
                    if (pu.type === 'invincibility') {
                        isInvincible = true;
                        isFlashing = false;
                        invincibilityTimer = invincibilityDuration;
                        playerSpeed = 12;
                    } else if (pu.type === 'shield') {
                        isShielded = true;
                        shieldTimer = shieldDuration;
                    } else if (pu.type === 'magnetic' && !pu.generatedByMagnet) {
                        isMagnetic = true;
                        magneticTimer = magneticDuration;
                        magneticSpawnCount = 2;
                    } else if (pu.type === 'extraLife') {
                        lives++;
                    }
                    powerups.splice(i, 1);
                }
            }

            if (!isInvincible) {
                for (let i = 0; i < obstacles.length; i++) {
                    const obs = obstacles[i];
                    
                    if (isColliding(obs)) {
                        let animColor = 'red';
                        if (isShielded) {
                            animColor = 'cyan';
                            isShielded = false;
                            isInvincible = true;
                            invincibilityTimer = invincibilityAfterShieldDuration;
                            isFlashing = false;
                        } else {
                            lives--;
                            isInvincible = true;
                            invincibilityTimer = 1000;
                            isFlashing = true;
                            if (lives <= 0) {
                                endGame();
                            }
                        }
                        
                        const particles = [];
                        for(let j = 0; j < 10; j++) {
                            const angle = Math.random() * Math.PI * 2;
                            particles.push({
                                x: obs.x + obs.size / 2,
                                y: obs.y + obs.size / 2,
                                size: 5 + Math.random() * 5,
                                dx: Math.cos(angle) * (2 + Math.random() * 3),
                                dy: Math.sin(angle) * (2 + Math.random() * 3),
                            });
                        }
                        breakingAnimations.push({
                            particles: particles,
                            color: animColor,
                            lifetime: 500
                        });

                        obstacles.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        function drawCountdown() {
            const timeLeft = Math.max(0, Math.ceil((countdownStartTime + COUNTDOWN_DURATION - performance.now()) / 1000));
            ctx.fillStyle = 'white';
            ctx.font = '100px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(timeLeft, screenWidth / 2, screenHeight / 2);
            ctx.textAlign = 'left';
        }

        function drawScore() {
            ctx.fillStyle = 'white';
            ctx.font = '24px Arial';
            ctx.fillText('Pontuação: ' + Math.floor(score / 10), 10, 30);
        }

        function endGame() {
            gameOver = true;
            pauseButton.style.display = 'none';
            finalScoreDisplay.textContent = Math.floor(score / 10);
            gameOverScreen.style.display = 'flex';
            cancelAnimationFrame(animationFrameId);
        }

        function pauseGame() {
            isPaused = true;
            pauseMenu.style.display = 'flex';
            cancelAnimationFrame(animationFrameId);
            // Salva a velocidade atual dos obstáculos para restaurar depois
            targetObstacleSpeed = 2 + score / 750;
        }

        function resumeGame() {
            isPaused = false;
            pauseMenu.style.display = 'none';
            isCountingDown = true;
            countdownStartTime = performance.now();
            speedTransitionStartTime = null; // Reinicia o timer de transição
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            initialMenu.style.display = 'none';
            instructionsMenu.style.display = 'none';
            pauseButton.style.display = 'block';

            lives = 3;
            score = 0;
            obstacles = [];
            powerups = [];
            clouds = [];
            breakingAnimations = [];
            isInvincible = true;
            invincibilityTimer = initialInvincibilityDuration;
            isFlashing = false;
            isMagnetic = false;
            isShielded = false;
            
            if (playerImage.complete && playerImage.naturalHeight !== 0) {
                lastTime = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                playerImage.onload = () => {
                    lastTime = performance.now();
                    animationFrameId = requestAnimationFrame(gameLoop);
                };
                playerImage.onerror = () => {
                    drawPlayer = drawPlayerFallback;
                    lastTime = performance.now();
                    animationFrameId = requestAnimationFrame(gameLoop);
                };
            }
        }

        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;

            drawBackground();
            drawClouds();
            drawPlayer();
            drawObstacles();
            drawPowerups();
            drawBreakingAnimations();
            drawScore();
            drawLives();
            drawBonusTimer();

            if (isCountingDown) {
                drawCountdown();
                const elapsed = timestamp - countdownStartTime;
                if (elapsed >= COUNTDOWN_DURATION) {
                    isCountingDown = false;
                    speedTransitionStartTime = timestamp;
                    lastTime = timestamp;
                }
            } else if (!gameOver && !isPaused) {
                update(deltaTime);
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function showInstructions() {
            initialMenu.style.display = 'none';
            instructionsMenu.style.display = 'flex';
        }

        document.addEventListener('keydown', (e) => {
            if (gameOver || isPaused || isCountingDown) return;

            if (e.key === 'ArrowLeft' || e.key === 'a') {
                playerX -= playerSpeed;
            } else if (e.key === 'ArrowRight' || e.key === 'd') {
                playerX += playerSpeed;
            }

            if (playerX < 0) playerX = 0;
            if (playerX > screenWidth - playerWidth) playerX = screenWidth - playerWidth;

            if (e.key === 'p' || e.key === 'P') {
                if (isPaused) {
                    pauseGame();
                } else {
                    resumeGame();
                }
            }
        });

        canvas.addEventListener('mousedown', (e) => {
            if (gameOver || isPaused || isCountingDown) return;
            lastMouseX = e.clientX;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (gameOver || isPaused || isCountingDown || lastMouseX === null) return;
            
            const deltaX = e.clientX - lastMouseX;
            playerX += deltaX;
            lastMouseX = e.clientX;
            
            if (playerX < 0) playerX = 0;
            if (playerX > screenWidth - playerWidth) playerX = screenWidth - playerWidth;
        });

        canvas.addEventListener('mouseup', () => {
            lastMouseX = null;
        });
        
        canvas.addEventListener('mouseleave', () => {
            lastMouseX = null;
        });

        canvas.addEventListener('touchstart', (e) => {
            if (gameOver || isPaused || isCountingDown) return;
            const touch = e.touches[0];
            lastMouseX = touch.clientX;
        });

        canvas.addEventListener('touchmove', (e) => {
            if (gameOver || isPaused || isCountingDown) return;
            const touch = e.touches[0];
            if (lastMouseX !== null) {
                const deltaX = touch.clientX - lastMouseX;
                playerX += deltaX;
                lastMouseX = touch.clientX;
            }
            
            if (playerX < 0) playerX = 0;
            if (playerX > screenWidth - playerWidth) playerX = screenWidth - playerWidth;
        });
        
        canvas.addEventListener('touchend', () => {
            lastMouseX = null;
        });
        
        window.addEventListener('resize', handleResize);

        showInstructionsButton.addEventListener('click', showInstructions);
        startGameButton.addEventListener('click', startGame);
        resumeGameButton.addEventListener('click', resumeGame);
        pauseButton.addEventListener('click', pauseGame);
        
        playAgainButton.addEventListener('click', () => {
            window.location.reload();
        });
    </script>
    <audio id="bg-music" autoplay loop muted hidden>
      <source src="https://archive.org/download/call-the-shot/call-the-shot.mp3" type="audio/mpeg">
    </audio>

    <script>
      const audio = document.getElementById("bg-music");
      document.addEventListener("click", () => {
        audio.muted = false;
        audio.play();
      }, { once: true });
    </script>
    <!-- Overlay invisível -->
<div id="overlay" style="
  position:fixed;
  top:0; left:0;
  width:100vw; height:100vh;
  background:transparent;
  z-index:9999;
  cursor:pointer;
"></div>

<script>
  const overlay = document.getElementById("overlay");

  function enterFullscreen() {
    const elem = document.documentElement;
    if (elem.requestFullscreen) elem.requestFullscreen();
    else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
    else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
  }

  overlay.addEventListener("click", () => {
    overlay.style.display = "none"; // esconde o overlay depois do clique
    enterFullscreen();
  });

  document.addEventListener("fullscreenchange", () => {
    if (!document.fullscreenElement) {
      overlay.style.display = "block"; // volta se sair do fullscreen
    }
  });
</script>

</body>
</html>
